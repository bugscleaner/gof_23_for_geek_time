假设我们正在开发一个类似《天天酷跑》或者《QQ 卡丁车》这样的手游。这种游戏本身的
复杂度集中在客户端。后端基本上只负责数据（比如积分、生命值、装备）的更新和查询，
所以，后端逻辑相对于客户端来说，要简单很多。
考虑到你可能对游戏开发不熟悉，我这里稍微交代一些背景知识。
为了提高性能，我们会把游戏中玩家的信息保存在内存中。在游戏进行的过程中，只更新内
存中的数据，游戏结束之后，再将内存中的数据存档，也就是持久化到数据库中。为了降低
实现的难度，一般来说，同一个游戏场景里的玩家，会被分配到同一台服务上。这样，一个
玩家拉取同一个游戏场景中的其他玩家的信息，就不需要跨服务器去查找了，实现起来就简
单了很多。
一般来说，游戏客户端和服务器之间的数据交互是比较频繁的，所以，为了节省网络连接建
立的开销，客户端和服务器之间一般采用长连接的方式来通信。通信的格式有多种，比如
Protocol Buffer、JSON、XML，甚至可以自定义格式。不管是什么格式，客户端发送给服
务器的请求，一般都包括两部分内容：指令和数据。其中，指令我们也可以叫作事件，数据
是执行这个指令所需的数据。
服务器在接收到客户端的请求之后，会解析出指令和数据，并且根据指令的不同，执行不同
的处理逻辑。对于这样的一个业务场景，一般有两种架构实现思路。
常用的一种实现思路是利用多线程。一个线程接收请求，接收到请求之后，启动一个新的线
程来处理请求。具体点讲，一般是通过一个主线程来接收客户端发来的请求。每当接收到一
个请求之后，就从一个专门用来处理请求的线程池中，捞出一个空闲线程来处理。
另一种实现思路是在一个线程内轮询接收请求和处理请求。这种处理方式不太常见。尽管它
无法利用多线程多核处理的优势，但是对于 IO 密集型的业务来说，它避免了多线程不停切
换对性能的损耗，并且克服了多线程编程 Bug 比较难调试的缺点，也算是手游后端服务器
开发中比较常见的架构模式了。